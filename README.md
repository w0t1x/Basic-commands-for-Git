# **Шпаргалка для Git**

---

## **Тема 1: Создание Git проекта**

1. **Создаётся дириктория:**
```
mkdir … (создание файлов: touch …)
```
2. **Создаётся git ветка (master):** 
```
git init (Чтобы удалить ветку: rm -rf …) 
```
3. **Создаётся пользователь:** 
```
git config --global user.name “…”; <br> 
git config –global user.email … (проверка на подключение: cat ~/.gitconfig)
```
4. **Создаётся ключ SSH(нужно перейти в родительскую директорию: cd ~):** 
```
ssh-keygen -t ed25519 -C “рабочая почта”;
ssh-keygen -t rsa -b 4096 -C "рабочая почта" 
```
5. **Проверка создания ключа:**
```
ls -la .ssh/ 
```
6. **Копирование ключа и создание ключа на локале(github):** 
```
clip < ~/.ssh/id_ed25519/pub или clip < ~/.ssh/id_rsa.pub 
```

---

## **Тема 2: Привязка локального репозитория с удалённым** 

1. **Привязать удалённый репозиторий к локальному:**
```
git remote add origin … 
```
2. **Убедиться, что репозитории связаны:** 
```
git remote -v
```

---

## **Тема 3: Создание и добавление файлов**

1. **Подготовка добавления в git файлы:**
```
git add . или git add … и touch README.md 
```
2. **Проверка на добавления файлов:** 
```
git status 
```
3. **Добавление файлов:** 
```
git commit -m ‘…’ 
```
4. **Отправить изменения на удалённый репозиторий:** 
```
git push -u origin master (**Разбор: git push <-u пишется только первый раз, когда добавляешь. Дальше не надо> <название удалённого репозитория (пункт 1 тема 2)> <название текущей ветки>**) 
```

---

## **Тема 4: Клонирование репозитория** 

1.  **Клонировать репозиторий:** 
```
git clone …
```

---

## **Тема 5: Проверка работы JDK:**
1. **Проверка настройки:**
```
echo $JAVA_HOME и where java
```
3. **Проверки версии:**
```
java -version
```

---


## **Тема 6: Работа с JDK**
1. **Скомпилировать исходный код в байт-код:**
```
javac -encoding UTF-8 ….java. (Для нескольких файлов работает так же)
```
3. **Запускаем код:**
```
start ….java
```
2. **Запустить файл с байт-кодом:**
```
java -Dfile.encoding=UTF-8 (<тут находится файл с расширением .class>) (для нескольких файлов: java -cp <имя папки где храниться main в файле ….class> <файл где храниться main>)
```

---


## **Тема 7: Работа с JAR**
1. **Переводим в байт код (тема 5 пункт 1)**
2. **Создаём JAR:**
```
jar cfe <имя jar-файла> <имя стартового класса> <список файлов>  . (обязательно должны находиться в папке выше! ВНИМАТЕЛЬНО СМОТРИ НА ТОЧКУ)
ПРИМЕР: jar cfe library.jar Practicum -C bin .
```
4. **Запускаем JAR:**
```
java -jar ….jar
```
***!!! Если русский язык не выводится:*** 
```
chcp.com 65001
```

---


## **Тема 8: Работа внутри коммита**
1. **Просмотр информации о коммитах:**
```
git log (от англ. log, «журнал [записей]») — выведи подробную историю коммитов;
git log --oneline (от англ. log, «журнал [записей]» + one line, «одной строкой») — покажи краткую информацию о коммитах: сокращённый хеш и сообщение.
Просмотр состояния файлов
git status (от англ. status, «статус», «состояние») — покажи текущее состояние репозитория.
```
2. **Добавление изменений в последний коммит:**
```
git commit --amend --no-edit (от англ. amend, «исправить») — добавь изменения к последнему коммиту и оставь сообщение прежним;
git commit --amend -m "Новое сообщение" — измени сообщение к последнему коммиту на Новое сообщение.
```
***Выйти из редактора Vim: нажать Esc, ввести :qa!, нажать Enter.***  
3. **«Откат» файлов и коммитов:**
```
git restore --staged hello.txt (от англ. restore, «восстановить») — переведи файл hello.txt из состояния staged обратно в untracked или modified;
git restore hello.txt — верни файл hello.txt к последней версии, которая была сохранена через git commit или git add;
git reset --hard b576d89 (от англ. reset, «сброс», «обнуление» + hard, «суровый») — удали все незакоммиченные изменения из staging и «рабочей зоны» вплоть до указанного коммита.
```
4. **Просмотр изменений:**
```
git diff (от англ. difference, «отличие», «разница») — покажи изменения в «рабочей зоне», то есть в modified-файлах;
git diff a9928ab 11bada1 — выведи разницу между двумя коммитами;
git diff --staged — покажи изменения, которые добавлены в staged-файлах.
```

---


## **Тема 9: Основы работы с ветками**
1. **Создание веток:**
```
git branch feature/the-finest-branch (от англ. branch, «ветка») — создай ветку от текущей с названием feature/the-finest-branch;
git checkout -b feature/the-finest-branch — создай ветку feature/the-finest-branch и сразу переключись на неё.
```
2. **Навигация по веткам:**
```
git branch — покажи, какие есть ветки в репозитории и в какой из них я нахожусь (текущая ветка будет отмечена символом *);
git branch -a — покажи все известные ветки, как локальные (в локальном репозитории), так и удалённые (в origin на GitHub);
git checkout feature/br — переключись на ветку feature/br.
```
3. **Сравнение веток:**
```
git diff main HEAD (от англ. difference, «отличие», «разница») — покажи разницу между веткой main и указателем на HEAD;
git diff HEAD~2 HEAD — покажи разницу между тем коммитом, который был два коммита назад, и текущим.
```
4. **Удаление веток:**
```
git branch -d br-name — удали ветку br-name, но только если она является частью main;
git branch -D br-name — удали ветку br-name, даже если она не объединена с main.
```
5. **Слияние веток:**
```
git merge main (от англ. merge, «сливать», «поглощать») — объедини ветку main с текущей активной веткой. 
```
6. **Работа с удалённым репозиторием**
```
git push -u origin my-branch (от англ. push, «толкнуть», «протолкнуть») — отправь новую ветку my-branch в удалённый репозиторий и свяжи локальную ветку с удалённой, чтобы при дополнительных коммитах можно было писать просто git push, без -u;
git push my-branch — отправь дополнительные изменения в ветку my-branch, которая уже существует в удалённом репозитории;
git pull (от англ. pull, «вытянуть») — подтяни изменения текущей ветки из удалённого репозитория.
```